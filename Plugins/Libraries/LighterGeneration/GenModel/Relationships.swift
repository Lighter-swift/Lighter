//
//  Created by Helge Heß.
//  Copyright © 2022 ZeeZide GmbH.
//

public extension EntityInfo {
  // Those are generated by the Fancifier instead of the plain codegen,
  // because it involves name mapping.
  
  /**
   * Relationship information for to-one foreign keys. Pointing from the
   * record having the foreign key, to the one that should have the value.
   *
   * Either side could be optional!
   *
   * The name doesn't have to be the `destinationEntity.name`, but often is.
   * E.g. for `owner_id` targetting the `person` table, it could be
   * "Owner" (and then `findOwner(for record: ...)`).
   *
   * Will generate on `SQLDatabaseFetchOperations` for name-matching ones:
   * ```
   * func findDestination(for sourceRecord: Source) throws -> Destination? {
   *   try self[dynamicMember: \.sourceReferenceName]
   *    .findTarget(for: \.sourceProperty, in: sourceRecord)
   * }
   * ```
   */
  struct ToOne { // attached to source entity
    
    public let name               : String     // Person   (=> findPerson)
    public let destinationEntity  : EntityInfo // Person
    public let sourcePropertyName : String     // personId (=> \.personId)
    public let isPrimary          : Bool       // whether name must be added
    
    public var hasNameMatchingDestinationRecord : Bool {
      name == destinationEntity.name
    }
  }
  
  /**
   * Relationship for the inverse of the foreign-key.
   *
   * Technically this could still be a 1:1, but we can't know just from the
   * schema and hence must assume 1:n.
   *
   * Note: This should probably not have multiple matches.
   *
   * Will generate on `SQLDatabaseFetchOperations` for name-matching ones:
   * ```
   * func fetchSource[es](for destinationRecord: Destination,
   *                      omitEmpty: Bool = false, limit: Int? = nil)
   *        throws -> [ Source ]
   * {
   *   try self[dynamicMember: \.sourceReferenceName]
   *     .fetch(for: \.sourceProperty, in: destinationRecord, limit: limit)
   * }
   * ```
   */
  struct ToMany { // attached to destination entity
    
    public let name               : String     // Addresses (=> fetchAddresses)
    public let sourceEntity       : EntityInfo // Address
    public let sourcePropertyName : String     // personId (=> \.personId)
    public let qualifierParameter : String?    // `Owner` (=> `forOwner:`)
  }
}

extension EntityInfo.ToOne: CustomStringConvertible {
  
  public var description: String {
    var ms = "<ToOne[\(name)]: to=\(destinationEntity.name)"
    ms += " via=\(sourcePropertyName)"
    if isPrimary { ms += " primary" }
    ms += ">"
    return ms
  }
}

extension EntityInfo.ToMany: CustomStringConvertible {
  
  public var description: String {
    var ms = "<ToMany[\(name)]: from=\(sourceEntity.name)"
    ms += " via=\(sourcePropertyName)"
    if let qp = qualifierParameter { ms += " qp=\(qp)" }
    else                           { ms += " primary"  }
    ms += ">"
    return ms
  }
}
