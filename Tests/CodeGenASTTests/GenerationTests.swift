//
//  Created by Helge Heß.
//  Copyright © 2022 ZeeZide GmbH.
//

import XCTest
@testable import LighterCodeGenAST

final class GenerationTests: XCTestCase {
  
  typealias Expression = LighterCodeGenAST.Expression
  
  func testExtensionWithTypeConstraint() {
    /*
     extension SQLDatabaseFetchOperations
     where RecordTypes == OurDatabase.RecordTypes
     {
     }
     */
    let function : FunctionDefinition = Fixtures.makeSelectDefinition()
    let ext  = Extension(
      extendedType: .name("SQLDatabaseFetchOperations"),
      genericConstraints: [
        .equal(name: "RecordTypes",
               type: .qualifiedType(baseName: "OurDatabase",
                                    name: "RecordTypes"))
      ],
      functions: [ function ]
    )
    
    let source : String = {
      let builder = CodeGenerator()
      builder.generateExtension(ext)
      return builder.source
    }()
    
    //print("GOT:\n-----\n\(source)\n-----")
    
    XCTAssertTrue(source.contains(
      "public extension SQLDatabaseFetchOperations"))
    XCTAssertTrue(source.contains(
      "where RecordTypes == OurDatabase.RecordTypes"))
  }
  
  func testExtension() {
    let f    : FunctionDefinition = Fixtures.makeSelectDefinition()
    let ext  = Extension(extendedType: .name("SQLDatabaseFetchOperations"),
                         functions: [ f ])
    
    let source : String = {
      let builder = CodeGenerator()
      builder.generateExtension(ext)
      return builder.source
    }()
    
    //print("GOT:\n-----\n\(source)\n-----")
    
    let expected =
    """
    public extension SQLDatabaseFetchOperations {
      
      func select<T, C1, C2>(
        from table: KeyPath<Self.RecordTypes, T.Type>,
        _ column1: KeyPath<T.Schema, C1>,
        _ column2: KeyPath<T.Schema, C2>,
        _ limit: Int? = nil,
        _ yield: ( C1.Value, C2.Value ) -> Void
      ) throws
        where C1: SQLColumn, C2: SQLColumn, T == C1.T, T == C2.T
      {
        var builder = SQLBuilder<T>()
        builder.addColumn(column1)
        builder.addColumn(column2)
        let sql = builder.generateSelect(limit: limit, predicate: SQLTruePredicate.shared)
        try fetch(sql, builder.bindings) { ( stmt, _ ) in
          yield(
            try C1.Value.init(unsafeSQLite3StatementHandle: stmt, column: 1),
            try C2.Value.init(unsafeSQLite3StatementHandle: stmt, column: 2)
          )
        }
      }
    }
    
    """
    XCTAssertEqual(source, expected)
  }
  
  func testEmptyPublicStruct() {
    let s = Struct(public: true, name: "RecordTypes")
    
    let source : String = {
      let builder = CodeGenerator()
      builder.generateStruct(s)
      return builder.source
    }()
    
    //print("GOT:\n-----\n\(source)\n-----")
    
    let expected =
    """
    public struct RecordTypes {
    }
    
    """
    XCTAssertEqual(source, expected)
  }
  
  func testExtensionWithStruct() {
    let s   = Struct(public: true, name: "RecordTypes")
    let ext = Extension(extendedType: .name("SQLDatabaseFetchOperations"),
                        structures: [ s ])
    
    let source : String = {
      let builder = CodeGenerator()
      builder.generateExtension(ext)
      return builder.source
    }()
    
    //print("GOT:\n-----\n\(source)\n-----")
    
    let expected =
    """
    public extension SQLDatabaseFetchOperations {
      
      struct RecordTypes {
      }
    }
    
    """
    XCTAssertEqual(source, expected)
  }
  
  func testSimplePersonRecordStruct() {
    let source : String = {
      let builder = CodeGenerator()
      builder.generateStruct(Fixtures.personRecordStruct)
      return builder.source
    }()
    
    // print("GOT:\n-----\n\(source)\n-----")
    
    let expected =
    #"""
    /**
     * Record representing the `person` SQL table.
     *
     * Record types represent rows within tables in a SQLite database. They are
     * returned by the functions or queries/filters generated by Enlighter.
     *
     * ### Examples
     *
     * Perform record operations on ``Person`` records:
     * ```swift
     * let persons = try await db.persons.filter(orderBy: \.firstname) {
     *   $0.firstname != nil
     * }
     *
     * try await db.transaction { tx in
     *   var person  = try tx.persons.find(2) // find by primaryKey
     *   person.lastname = "Hunt"
     *
     *   try tx.update(person)
     *
     *   let newPerson = try tx.insert(person)
     *   try tx.delete(newPerson)
     * }
     * ```
     *
     * Perform column selects on ``Person`` records:
     * ```swift
     * let values = try await db.select(from: \.persons, \.lastname) {
     *   $0.in([ 2, 3 ])
     * }
     * ```
     *
     * Perform low level operations on ``Person`` records:
     * ```swift
     * var db : OpaquePointer?
     * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)
     *
     * let persons = try sqlite3_persons_fetch(db, orderBy: "name", limit: 5) {
     *   $0.firstname != nil
     * }
     *
     * persons[1].lastname = "Hunt"
     * sqlite3_persons_update(db, persons[1])
     *
     * sqlite3_persons_delete(db, persons[0])
     * sqlite3_persons_insert(db, persons[0]) // re-add
     * ```
     */
    public struct Person : SQLKeyedTableRecord, Identifiable {
      
      /// Static SQL type information for the `Person` record.
      public static let schema = Schema()
      
      /// Primary key `person_id`, SQL type `INT`, nullable.
      public var personId : Int?
      
      /// Column `lastname`, SQL type `TEXT`, not null
      public var lastname : String
      
      /// Column `firstname`, SQL type `TEXT`, nullable
      public var firstname : String?
      
      /// Returns the ``personId`` primary key of the record.
      @inlinable
      public var id : Int { personId }
      
      /**
       * Initialize a new ``Person`` record.
       *
       * - Parameters:
       *   - personId: Primary key in SQL column `person_id`, defaults to `0`
       *   - lastname: SQL column `lastname`, required.
       *   - firstname: SQL column `firstname`, optional, defaults to `nil`.
       */
      @inlinable
      public init(personId: Int = 0, lastname: String, firstname: String? = nil)
      {
        self.personId = personId
        self.lastname = lastname
        self.firstname = firstname
      }
    }
    
    """#
    // Xcode borks this even within a raw string literal
      .replacingOccurrences(of: " *\n", with: " * \n")
    
    if source != expected {
      let sourceLines   = source.split  (separator: "\n",
                                         omittingEmptySubsequences: false)
      let expectedLines = expected.split(separator: "\n",
                                         omittingEmptySubsequences: false)
      var line = 0
      for ( source, expected ) in zip(sourceLines, expectedLines) {
        line += 1
        if source != expected {
          print("Line[\(line)]: Mismatch \(source.count) vs \(expected.count)")
          print("S:|\(source)|")
          print("E:|\(expected)|")
        }
      }
      
      XCTFail("Source doesn't match expectation.")
    }
  }
  
  func testPersonRecordSchemaExtensions() {
    
    func makeMappedColumn(for type: String,
                          property: String, type propertyType: String,
                          defaultValue: Expression,
                          column: String) -> Expression
    {
      .call(
        name: "MappedColumn<\(type), \(propertyType)>", // Hmmm
        parameters: [
          ( "externalName" , .string(column) ),
          ( "defaultValue" , defaultValue ),
          ( "keyPath"      , .keyPath(.name(type), property) )
        ]
      )
    }
    
    let schemaStruct = Struct(
      public: true, name: "Schema",
      conformances: [ .name("SQLKeyedTableSchema"),
                      .name("SQLSwiftMatchableSchema") ],
      typeAliases: [
        ( "PropertyIndices", .tuple(
          names: [ "idx_personId", "idx_lastname", "idx_firstname" ],
          types: [ .int32, .int32, .int32 ]
        )),
        ( "RecordType", .name("Person") )
      ],
      typeVariables: [
        .let("externalName", is: .string("person"),
             comment:
              "The SQL table name associated with the ``Person`` record."),
        // Only generate this when Lighter is enabled! (another thing for raw?)
        .let("primaryKeyColumn", // Note: really optional!
             is: makeMappedColumn(for: "Person", property: "personId",
                                  type: "Int", defaultValue: .integer(-1),
                                  column: "person_id"),
             comment:
              "Information on the records primary key (``Person/personId``)."
            ),
        .let("columnCount", type: .int32, is: .integer(3),
             comment: "The number of columns the `person` table has."),
        .let("create", is: .string(#"""
            CREATE TABLE person (
              person_id INTEGER PRIMARY KEY NOT NULL,
              
              firstname VARCHAR NULL,
              lastname  VARCHAR NOT NULL
            );
            """#), comment: "The SQL used to create the `person` table."),
        .let("select", is: .string(#"SELECT \(selectColumns) FROM person"#),
             comment: "SQL to SELECT all columns of the `person` table."),
        .let("selectColumns", is: .string("person_id, lastname, firstname"),
             comment: "SQL fragment representing all columns."),
        .let("selectColumnIndices", type: .name("PropertyIndices"),
             is: .tuple([ .integer(0), .integer(1), .integer(2) ]),
             comment: "Index positions of the properties in ``selectColumns``.")
        
      ],
      variables: [
        // Only generate those when Lighter is enabled!
        // Remember: The default values are Swift values that may need to be
        //           casted from the SQL column default. Also, they are
        //           REQUIRED for non-null columns!
        .let("personId", // Note: really optional!
             is: makeMappedColumn(for: "Person", property: "personId",
                                  type: "Int", defaultValue: .integer(-1),
                                  column: "person_id"),
             comment:
              "Type information for ``Person/personId`` (`person_id` column)."
            ),
        .let("lastname", // Note: really optional!
             is: makeMappedColumn(for: "Person", property: "lastname",
                                  type: "String", defaultValue: .string(""),
                                  column: "lastname"),
             comment:
              "Type information for ``Person/lastname`` (`lastname` column)."
            ),
        .let("firstname", // Note: really optional!
             is: makeMappedColumn(for: "Person", property: "firstname",
                                  type: "String?", defaultValue: .nil,
                                  column: "firstname"),
             comment:
              "Type information for ``Person/firstname`` (`firstname` column)."
            )
      ],
      computedProperties: [
      ],
      functions: [
        .init(
          /*
           public static func lookupColumnIndices(in statement: OpaquePointer)
           -> PropertyIndices
           */
          declaration: .call(
            "lookupColumnIndices",
            returns: .name("PropertyIndices"),
            .init(keyword: "in", name: "statement", type: .name("OpaquePointer"))
          ),
          statements: [
            /*
             { // we can generate this, as we know the column count!
             var indices : PropertyIndices = ( -1, -1, -1 )
             for i in 0..<sqlite3_column_count(statement) {
             let col = sqlite3_column_name(statement, i)
             // could be made faster by returning early and by only strcmp when the
             // idx is not yet set
             if      strcmp(col!, "person_id") == 0 { indices.idx_personId  = i }
             else if strcmp(col!, "lastname")  == 0 { indices.idx_lastname  = i }
             else if strcmp(col!, "firstname") == 0 { indices.idx_firstname = i }
             }
             return indices
             }
             */
            .var("indices", type: .name("PropertyIndices"),
                 .tuple(Array(repeating: .integer(-1), count: 3))),
            .forInRange(
              counter: "i", from: .integer(0),
              to: .call(name: "sqlite3_column_count", .variable("statement")),
              statements: [
                .constantDefinition(
                  name: "col",
                  value: .call(name: "sqlite3_column_name",
                               .variable("statement"), .variable("i"))
                ),
                .ifSwitch( // TBD: allow generation w/ strcasecmp?
                  ( .callIs0("strcmp", .variable("col"), .string("person_id") ),
                    .set(instance: "indices", "idx_personId", .variable("i")) ),
                  ( .callIs0("strcmp", .variable("col"), .string("lastname") ),
                    .set(instance: "indices", "idx_lastname", .variable("i")) ),
                  ( .callIs0("strcmp", .variable("col"), .string("firstname") ),
                    .set(instance: "indices", "idx_firstname", .variable("i")) )
                         )
              ]
            ),
            .return(.variable("indices"))
          ],
          comment: .init(
            headline:
              "Lookup property indices by column name in a statement handle.",
            info:
              """
              Properties are ordered in the schema and have a specific index
              assigned.
              E.g. if the record has two properties, `personId` and `name`,
              and the query was `SELECT age, person_id FROM person`,
              this would return `( idx_personId: 1, idx_name: -1 )`.
              Because the `person_id` is in the second position and `name`
              isn't provided at all.
              """,
            parameters: [
              .init(name: "statement",
                    info: "A raw SQLite3 prepared statement handle.")
            ],
            returnInfo:
              "The positions of the properties in the prepared statement."
          ),
          inlinable: true
        )
      ],
      comment: .init(
        headline:
          "Static type information for the ``Person`` record (`person` SQL table).",
        info:
          """
          This structure captures the static SQL information associated with the
          record.
          It is used for static type lookups and more.
          """
      )
    )
    
    let ext = Extension(extendedType: .name("Person"),
                        structures: [ schemaStruct ])
    
    let source : String = {
      let builder = CodeGenerator()
      builder.generateExtension(ext)
      return builder.source
    }()
    
    //print("GOT:\n-----\n\(source)\n-----")
    
    XCTAssertTrue(source.contains("CREATE TABLE person ("))
    XCTAssertTrue(source.contains(##"public static let select = #"SELECT"##))
    XCTAssertTrue(source.contains("typealias PropertyIndices = ( idx_personId"))
    XCTAssertTrue(source.contains("typealias RecordType = Person"))
    XCTAssertTrue(source.contains(
      "struct Schema : SQLKeyedTableSchema, SQLSwiftMatchableSchema"))
    XCTAssertTrue(source.contains(#"keyPath: \Person.personId"#))
  }
  
  func testPersonRecordBindGeneration() {
    /* generate this:
     func withOptCString(_ s: String?, _ body: (UnsafePointer<CChar>?) throws -> R)
     rethrows -> R
     {
     if let s = s { return try s.withCString(body) }
     else { return try body(nil) }
     }
     */
    func makeWithOptCString() -> FunctionDefinition {
      FunctionDefinition(
        declaration: FunctionDeclaration(
          public: false, name: "withOptCString",
          parameters: [
            .init(name: "s", type: .optional(.string)),
            .init(name: "body", type: .closure(
              escaping: false,
              parameters: [ .optional(.name("UnsafePointer<CChar>")) ],
              throws: true, returns: .name("R")
            ))
          ],
          rethrows: true, returnType: .name("R")
        ),
        statements: [
          .raw("if let s = s { return try s.withCString(body) }"),
          .raw("else         { return try body(nil)           }")
        ]
      )
    }
    
    // for the binds the generation needs to recurse backwards
    let bindFunc = FunctionDefinition(
      declaration: FunctionDeclaration(
        public: true, name: "bind", genericParameterNames: [ "R" ],
        parameters: [
          .init(keyword: "to", name: "statement",
                type: .name("OpaquePointer!")),
          .init(keywordArg: "indices",
                .qualifiedType(baseName: "Schema", name: "PropertyIndices")),
          .init(keyword: "then", name: "execute",
                type: .closure(escaping: false, parameters: [], throws: true,
                               returns: .name("R")))
        ],
        async: false, throws: false, rethrows: true,
        returnType: .name("R"),
        genericConstraints: []
      ),
      statements: [
        // only generate if required (always? :-) )
        // if we link Lighter, it has `withCString` defined
        .nestedFunction(makeWithOptCString()),
        
        // in here we need the nested generation.
        // I.e. we walk the properties. If we find a bind-requiring type,
        // we stop walking, return with a recurse on the subset of remaining
        // properties.
        
          .ifSwitch((
            .gtOrEq0(.variable("indices", "idx_personId")),
            Statement.call(name: "sqlite3_bind_int64",
                           .variable("statement"),
                           .variable("indices", "idx_personId"),
                           .cast(.variable("personId"), to: .name("Int64")))
          )),
        .return(
          // always the same pattern for texts:
          // first "if-switch", then continue binding
          .call(try: true, instance: "lastname", name: "withCString",
                parameters: [], trailing: ( [ "s" ], [
                  // statements:
                  .ifSwitch((
                    .gtOrEq0(.variable("indices", "idx_lastname")),
                    Statement.call(name: "sqlite3_bind_text",
                                   .variable("statement"),
                                   .variable("indices", "idx_lastname"),
                                   .variable("s"), .integer(-1), .nil)
                  )),
                  // next one is again requiring a bind, this time optional
                  .return(
                    .call(try: true, name: "withOptCString",
                          parameters: [ ( nil, .variable("firstname") ) ],
                          trailing: ( [ "s" ], [
                            // statements:
                            .ifSwitch((
                              .gtOrEq0(.variable("indices", "idx_firstname")),
                              Statement.call(name: "sqlite3_bind_text",
                                             .variable("statement"),
                                             .variable("indices", "idx_firstname"),
                                             .variable("s"), .integer(-1), .nil)
                            )),
                            
                            // and here we end the recursion by calling the
                            // nested function
                              .return(.call(try: true, name: "execute"))
                          ]))
                  )
                ]))
        )
      ],
      comment: .init(
        headline:
          "Bind all record values to a prepared statement and call a closure.",
        info:
          """
          *Important*: The bindings are only valid within the closure being executed!
          """,
        example:
        """
        var statement : OpaquePointer?
        sqlite3_prepare_v2(
          dbHandle,
          "UPDATE person SET lastname = ?, firstname = ? WHERE person_id = ?",
          -1, &statement, nil
        )
        
        let donald = Person(personId: 1, lastname: "Duck", firstname: "Donald")
        donald.bind(to: statement,
          indices: ( idx_personId: 3, idx_lastname: 1, idx_firstname: 2 )
        ) {
          sqlite3_step(statement)
        }
        
        sqlite3_finalize(statement)
        """,
        parameters: [
          .init(name: "statement",
                info: "A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions."),
          .init(name: "indices",
                info: "The parameter positions for the bindings."),
          .init(name: "execute",
                info: "A closure to execute when all bindings have been applied, "
                + "the bindings are _only_ valid within that closure!")
          
        ],
        throws: true,
        returnInfo: "Returns the result of the closure that is passed in."
      ),
      inlinable: true, discardableResult: true
    )
    
    let ext = Extension(extendedType: .name("Person"), functions: [ bindFunc ])
    
    let source : String = {
      let builder = CodeGenerator()
      builder.generateExtension(ext)
      return builder.source
    }()
    
    //print("GOT:\n-----\n\(source)\n-----")
    
    XCTAssertTrue(source.contains(
      "return try withOptCString(firstname) { ( s ) in"))
    XCTAssertTrue(source.contains(
      "sqlite3_bind_text(statement, indices.idx_firstname, s, -1, nil)"))
    XCTAssertTrue(source.contains("return try execute()"))
    
    XCTAssertTrue(source.contains(
      "func withOptCString(_ s: String?, _ body: ( UnsafePointer<CChar"))
  }
  
  func testPersonRecordInitGeneration() {
    let propertyIndexPrefix = "idx_"
    
    func index(for propertyName: String) -> Expression {
      .variable("indices", "\(propertyIndexPrefix)\(propertyName)")
    }

    /// Make sure the property index is within the allowed range:
    /// `indices.idx_personId >= 0 && indices.idx_personId < argc`
    /// E.g. it could be `-1` if it wasn't requested.
    func makeIndexCheck(for propertyName: String) -> Expression {
      let idx = index(for: propertyName)
      return Expression.and([
        .cmp(idx, .greaterThanOrEqual, 0),
        .cmp(idx, .lessThan, .variable("argc"))
      ])
    }
    /// Make sure the property index is within the allowed range:
    /// `indices.idx_personId >= 0 && indices.idx_personId < argc`
    /// *and* that it isn't null if available:
    /// `sqlite3_column_type(stmt, indices.idx_personId) != SQLITE_NULL)`.
    /// E.g. it could be `-1` if it wasn't requested.
    func makeNullIndexCheck(for propertyName: String) -> Expression {
      let idx = index(for: propertyName)
      return Expression.and([
        .cmp(idx, .greaterThanOrEqual, 0),
        .cmp(idx, .lessThan, .variable("argc")),
        .cmp(
          .call(name: "sqlite3_column_type", .variable("statement"), idx),
          .notEqual,
          .variable("SQLITE_NULL")
        )
      ])
    }
    func grabIntColumnValue(for propertyName: String) -> Expression {
      return .conditional(
        makeNullIndexCheck(for: propertyName),
        .cast(
          .call(name: "sqlite3_column_int64",
                .variable("statement"), index(for: propertyName)),
          to: .int
        ),
        .variablePath([ "Self", "schema", propertyName, "defaultValue" ])
      )
    }
    func grabOptIntColumnValue(for propertyName: String) -> Expression {
      let idx = index(for: propertyName)
      return .conditional(
        makeIndexCheck(for: propertyName),
        // provided, but can be nil!
        .conditional(
          .cmp(
            .call(name: "sqlite3_column_type", .variable("statement"), idx),
            .notEqual,
            .variable("SQLITE_NULL")
          ),
          .cast(
            .call(name: "sqlite3_column_int64", .variable("statement"), idx),
            to: .int
          ),
          .nil
        ),
        // not provided, use default
        .variablePath([ "Self", "schema", propertyName, "defaultValue" ])
      )
    }
    /// This ONLY applies the default value, if the index check fails (i.e. the
    /// property is not part of the result)
    func grabOptStringColumnValue(for propertyName: String) -> Expression {
      return .conditional(
        makeIndexCheck(for: propertyName), // is it available?
        .flatMap(expression:
                  .call(name: "sqlite3_column_text",
                        .variable("statement"), index(for: propertyName)),
                 map: .raw("String.init(cString:)")),
        .variablePath([ "Self", "schema", propertyName, "defaultValue" ])
      )
    }
    /// This applies the default value if the index check fails (i.e. the
    /// property is not part of the result)
    /// OR if the value is `NULL` in the result!
    func grabStringColumnValue(for propertyName: String) -> Expression {
      .nilCoalesce(
        .conditional(
          makeIndexCheck(for: propertyName), // is it available?
          // custom types would need another flatmap here
          .flatMap(expression:
                    .call(name: "sqlite3_column_text",
                          .variable("statement"), index(for: propertyName)),
                   map: .raw("String.init(cString:)")),
          .nil
        ),
        // TBD: only valid for actual Strings!
        .variablePath([ "Self", "schema", propertyName, "defaultValue" ])
      )
    }

    // for the binds the generation needs to recurse backwards
    let personInit = FunctionDefinition(
      declaration: FunctionDeclaration(
        public: true, name: "init",
        parameters: [
          .init(name: "statement", type: .name("OpaquePointer!")),
          .init(keywordArg: "indices",
                .optional(
                  .qualifiedType(baseName: "Schema", name: "PropertyIndices")),
                .nil)
        ]
      ),
      statements: [
        //let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)
        .let("indices", is: .raw(
          "indices ?? Self.Schema.lookupColumnIndices(in: statement)")),
        //let argc    = sqlite3_column_count(statement)
        .let("argc",
          is: .call(name: "sqlite3_column_count", .variable("statement"))
        ),
        
        .selfInit(
          ( "personId"  , grabOptIntColumnValue(for: "personId") ),
          ( "lastname"  , grabStringColumnValue(for: "lastname") ),
          ( "firstname" , grabOptStringColumnValue(for: "firstname") )
        )
      ],
      comment: .init(
        headline:
          "Initialize a ``Person`` record from a prepared statement handle.",
        info: nil,
        example:
        """
        var statement : OpaquePointer?
        sqlite3_prepare_v2(dbHandle, "SELECT * FROM person", -1, &statement, nil)
        if sqlite3_step(statement) == SQLITE_ROW {
          let person = Person(statement)
        }
        sqlite3_finalize(statement)
        """,
        parameters: [
          .init(name: "statement",
                info: "Statement handle as returned by `sqlite3_prepare*` functions."),
          .init(name: "indices",
                info: "Property bindings positions, "
                    + "defaults to `nil` (automatic lookup).")
          
        ]
      ),
      inlinable: true
    )

    
    let ext = Extension(extendedType: .name("Person"),
                        functions: [ personInit ])
    
    let source : String = {
      let builder = CodeGenerator()
      builder.generateExtension(ext)
      return builder.source
    }()
    
    // print("GOT:\n-----\n\(source)\n-----")
    
    XCTAssertTrue(source.contains(
      "indices ?? Self.Schema.lookupColumnIndices(in: statement"))
    XCTAssertTrue(source.contains("argc = sqlite3_column_count"))
    XCTAssertTrue(source.contains("self.init("))
    XCTAssertTrue(source.contains(
      "init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices"))
    XCTAssertTrue(source.contains(
      "personId: (indices.idx_personId >= 0) && (indices.idx_personId < argc) "
    + "? (sqlite3_column_type(statement, indices.idx_personId) != SQLITE_NULL "
    + "? Int(sqlite3_column_int"))
    XCTAssertTrue(source.contains("flatMap(String.init(cString:))) : nil"))
    XCTAssertTrue(source.contains(": Self.schema.firstname"))
    XCTAssertTrue(source.contains("Self.schema.lastname.defaultValue"))
  }
}
